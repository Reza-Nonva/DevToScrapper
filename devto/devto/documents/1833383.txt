
            AI-assisted coding is lowering the barrier to making software. It‚Äôs also increasing the complexity of managing it. You can make applications with less upfront knowledge than before, and organizations are having to figure out how to handle the ensuing unpredictability and risk. So it‚Äôs getting easier and harder.

Building software became unnecessarily difficult over the last few years in my opinion. We switched to frameworks that closed a lot of the doors to opportunity we‚Äôd seen open in the earlier years of the web. Now there‚Äôs a widening divide between those with the skills to make software ‚Äúproperly‚Äù and those who are no longer prevented from participating by this gatekeeping. Then we have the threat of jobs being eliminated because some executives think AI removes the need for engineers. It's a bit of a mess.

Working in developer education, I often ask myself if I‚Äôm teaching the right skills, the ones that are worth learning. It‚Äôs getting harder to make reliable guesses about which topics will enable people to make the web and get paid doing it.


  
  
  For most of us it isn‚Äôt about the tech


I recently set up a local developer environment for a project I wanted to contribute to. It was painful and I resented every minute of it lol. The actual contribution was easier than installing the tooling. 

In spite of essentially being paid to learn coding skills so that I can teach them to others, I find it incredibly hard to motivate myself to learn if the subject doesn't interest me. A lot of what‚Äôs involved in setting up local environments falls into that category. Compatibility between libraries, reciting the correct incantations of path and environment variables, that type of thing. These are not the parts I care about.

The same frustration kills the motivation to learn. For a new developer to spend hours configuring an environment before they can make a change to a web page that they can see in the browser is a big problem when it comes to learning. The motivating part is where you achieve something visible, tangible, significant to you ‚Äì that‚Äôs what builds momentum as you feel you‚Äôre making progress. Exasperating setup experiences tell the person ‚Äúthis is not for you‚Äù and most quietly go away.

The best motivator to learn any skill is a goal that is meaningful to you and that the skill is helping you to achieve. For most people, setting up an effective developer environment does not constitute such a goal.


If it does for you then congrats, but I believe you're in the minority! In the developer community there‚Äôs a wholesome passion for technical elegance, but unfortunately it‚Äôs frequently accompanied by an alienating disdain for those who don‚Äôt share the interest or understanding.



  
  
  It shouldn‚Äôt need to be hard


Earlier this year I ran employee training for my Fastly coworkers. I wanted to teach them to use our technical product in a way that absolutely anyone could engage with. Some colleagues feared this might be impossible, but for me, removing the expectation of prerequisite knowledge is a useful constraint ‚Äì it helps me make learning experiences that are better for everyone. So I gave myself ground rules like no local environment, no dev platform accounts or tooling like GitHub. And it was surprisingly successful!

This is part of why I‚Äôve always loved Glitch ‚Äì and how we got those employees to use our technical product by the way. It lets you jump straight to the parts of a project that are intuitively valuable and resonant to most people. I‚Äôd rather spend my time learning how to create the functionality or the experience I want to give users than installing the toolchain that only gets me to the starting line for that work.

If I never had to set up a dev environment again I simply would not. üíÖüèª


  
  
  Motivations do not need your validation


Today‚Äôs coding tools are abstracting away parts of software engineering that will invite many more people to the party and create significant challenges around maintenance, security, performance, and more. 

However attached we are to notions of correctness, of what people should know in order to create software, the reality is that most will not invest in something they don‚Äôt consider worth learning. You better believe people will flock to the tools that enable them without judgment or the expectation of virtuous toil! We can‚Äôt complain about this while insisting that the painful, exclusive alternative is the only valid one.

If we want software that is reliable, safe, and inclusive, we need to provide paths that empower a wide representation of people to build it. That means accepting the motivators they bring with them. 

Our goals determine what is and isn‚Äôt worth our time, and for most of us the technologies that help us get there are largely incidental. Those choices are driven by the opportunities each person is trying to unlock.

What makes something worth learning to you?


          